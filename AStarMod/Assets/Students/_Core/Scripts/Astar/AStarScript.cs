using System;
using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using Unity.VisualScripting;
using UnityEngine.UIElements;

public class AStarScript : MonoBehaviour {

	public bool check = true;

	//Assign class references to GridScript & Heurisitc Script.
	public GridScript gridScript;
	public CamNateHueristic hueristic;
	public FollowAStarScript followAstar;
	
	//Variables that determine the size of the Grid.
	protected int gridWidth;
	protected int gridHeight;

	//GameObject array that holds...
	GameObject[,] pos;

	//Positions for the start and end of the A* path. 
	protected Vector3 start;
	protected Vector3 goal;

	//Class reference to path script.
	public Path path;

	//Position of potential spaces as determined by PriorityQueue.
	protected PriorityQueue<Vector3> frontier;
	//
	protected Dictionary<Vector3, Vector3> cameFrom = new Dictionary<Vector3, Vector3>();
	protected Dictionary<Vector3, float> costSoFar = new Dictionary<Vector3, float>();
	//
	protected Vector3 current;

	//Positions of checked spaces in grid??
	List<Vector3> visited = new List<Vector3>();

	// Use this for initialization
	protected virtual void Start ()
	{
		followAstar = GameObject.Find("Princess").GetComponent<FollowAStarScript>();
		//InitAstar(); //Initializes A*
	}

	public virtual void InitAstar(){
		InitAstar(new Path(hueristic.gameObject.name, gridScript)); //Initializes A* based on hueristic parameters?
	}

	//this is the actual InitAstar function. this is being called for every path checked on the grid.
	protected virtual void InitAstar(Path path){
		this.path = path; //Assigns whatever path is being checked to the path that's named in the path class, 

		//Saves start and end vectors from grid script. 
		start = gridScript.start;
		goal = gridScript.goal;
		
		//Saves grid parameters as is determined by whats stated in gridScript.
		gridWidth = gridScript.gridWidth;
		gridHeight = gridScript.gridHeight;

		//populates our game object array witht the grid generated by grid script.
		pos = gridScript.GetGrid();

		//Assigns the queed grid box to the frontier as a vector. 
		frontier = new PriorityQueue<Vector3>();
		//adds the next grid box to the queue
		frontier.Enqueue(start, 0);

		//This is just setting us to the start posisiton since we're initializing the A*.
		cameFrom.Add(start, start);
		//Based on our position, since we have not moved our cost is zero.
		costSoFar.Add(start, 0);

		//since we're beginning at start, we have no explored nodes. 
		int exploredNodes = 0;

		//Since as we initialize a* and there is a frontier:
		while(frontier.Count != 0){
			exploredNodes++; //Adds to the number of explored nodes.
			current = frontier.Dequeue(); //and for the current node being explored it removes from the queue. 

			//after the current node has been dequeued it's being added to a list of visited vector3s.
			visited.Add(current);

			//changes the scale of explored nodes, to indicate they've been checked. 
			pos[(int)current.x, (int)current.y].transform.localScale = 
				Vector3.Scale(pos[(int)current.x, (int)current.y].transform.localScale, new Vector3(.8f, .8f, .8f));

			//if the current node is the goal.
			if(current.Equals(goal)){
				Debug.Log("GOOOAL!");
				break;//stops while loop.
			}
			
			//For the current grid, it's checking the left and right grid.
			for(int x = -1; x < 2; x+=2){
				AddNodesToFrontier((int)current.x + x, (int)current.y);
			}
			//This does the same as above but checks the top and bottom grid node. 
			for(int y = -1; y < 2; y+=2){
				AddNodesToFrontier((int)current.x, (int)current.y + y);
			}
			
			followAstar.SetPath();
		}
		
		//once we break out of the looop set current equal to goal. 
		current = goal;

		//draws a line yay. 
		LineRenderer line = GetComponent<LineRenderer>();

		//sets values for line drawing and score tallying?
		int i = 0;
		float score = 0;

		while(!current.Equals(start)){ //So while the current is not start
			line.positionCount++; //Draws another line. 
			
			//Storing the grid node
			GameObject go = pos[(int)current.x, (int)current.y];
			//adds the position to the path
			path.Insert(0, go, new Vector3((int)current.x, (int)current.y));

			current = cameFrom[current];

			Vector3 vec = Util.clone(go.transform.position);
			vec.z = -1;

			line.SetPosition(i, vec);
			score += gridScript.GetMovementCost(go);
			i++;
		}

		path.Insert(0, pos[(int)current.x, (int)current.y]);
		path.nodeInspected = exploredNodes;
		
		Debug.Log(path.pathName + " Terrian Score: " + score);
		Debug.Log(path.pathName + " Nodes Checked: " + exploredNodes);
		Debug.Log(path.pathName + " Total Score: " + (score + exploredNodes));
	}

	void AddNodesToFrontier(int x, int y){
		if(x >=0 && x < gridWidth && 
		   y >=0 && y < gridHeight)
		{
			Vector3 next = new Vector3(x, y);
			float new_cost = costSoFar[current] + gridScript.GetMovementCost(pos[x, y]);
			if(!costSoFar.ContainsKey(next) || new_cost < costSoFar[next])
			{
				costSoFar[next] = new_cost;
				float priority = new_cost + hueristic.Hueristic(x, y, start, goal, gridScript);

				frontier.Enqueue(next, priority);
				cameFrom[next] = current;
			}
		}
	}

	// Update is called once per frame
	void Update () {
	
	}
}
